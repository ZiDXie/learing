# vector 和 array区别

**动态与静态**

vector: 动态数组，大小可随元素增减自动调整。

array: 静态数组，大小固定，定义后不能改变。

**内存管理**

vector: 自动管理内存，元素增加时会重新分配内存。

array: 内存分配在栈上，大小固定，无动态内存管理。

**性能**

vector: 动态调整大小可能带来额外开销，但访问元素与 array 一样高效。

array: 性能更高，因内存连续且无动态调整开销。

**使用场景**

vector: 适用于元素数量不确定或频繁变化的场景。

array: 适用于元素数量固定且已知的场景。

**初始化**

vector: 可以使用初始化列表或默认构造函数。

array: 必须指定大小，且大小在编译时确定。

------

# CPP VECTOR 容器

详见[网址](https://www.runoob.com/cplusplus/cpp-vector.html)

# 二分查找

**题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

------

## while查找边界的定义

**区间的定义这就决定了二分法的代码应该如何写**

### 左闭右闭区间

- 定义区间**[left, right]**，此时应使`left <= right`因为此时`left == right`是有意义的。

- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### 左闭右开区间

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

------

## 防止溢出

```
int middle = left + ((right - left) / 2);
```

### **为什么这样写可以防止溢出？**

- 直接使用 `(left + right) / 2` 可能会导致整数溢出。
  - 例如，如果 `left` 和 `right` 都接近 `INT_MAX`（即 `int` 类型的最大值），`left + right` 会超出 `int` 的范围，导致溢出。
- 通过改写为 `left + ((right - left) / 2)`，可以避免溢出：
  - `(right - left)` 计算的是 `left` 和 `right` 之间的距离，这个值通常比 `left + right` 小得多，不容易溢出。
  - 然后除以 2，再加上 `left`，得到中间值。

### 适用场景

这种写法常用于二分查找（Binary Search）算法中，用于计算中间索引。二分查找需要对数组或区间的中间值进行计算，而 `left` 和 `right` 可能会非常大，因此需要避免溢出。

------

# 双指针法

**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。
