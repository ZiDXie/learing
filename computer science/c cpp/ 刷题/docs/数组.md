# vector 和 array区别

**动态与静态**

vector: 动态数组，大小可随元素增减自动调整。

array: 静态数组，大小固定，定义后不能改变。

**内存管理**

vector: 自动管理内存，元素增加时会重新分配内存。

array: 内存分配在栈上，大小固定，无动态内存管理。

**性能**

vector: 动态调整大小可能带来额外开销，但访问元素与 array 一样高效。

array: 性能更高，因内存连续且无动态调整开销。

**使用场景**

vector: 适用于元素数量不确定或频繁变化的场景。

array: 适用于元素数量固定且已知的场景。

**初始化**

vector: 可以使用初始化列表或默认构造函数。

array: 必须指定大小，且大小在编译时确定。

------

# CPP VECTOR 容器

详见[网址](https://www.runoob.com/cplusplus/cpp-vector.html)

vector创建二维数组

```cpp
  vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
```

# 二分查找

**题目的前提是数组为有序数组**，同时题目还强调**数组中无重复元素**，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的，这些都是使用二分法的前提条件，当大家看到题目描述满足如上条件的时候，可要想一想是不是可以用二分法了。

写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

------

## while查找边界的定义

**区间的定义这就决定了二分法的代码应该如何写**

### 左闭右闭区间

- 定义区间**[left, right]**，此时应使`left <= right`因为此时`left == right`是有意义的。

- if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

### 左闭右开区间

- while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
- if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

------

## 防止溢出

```cpp
int middle = left + ((right - left) / 2);
```

### **为什么这样写可以防止溢出？**

- 直接使用 `(left + right) / 2` 可能会导致整数溢出。
  - 例如，如果 `left` 和 `right` 都接近 `INT_MAX`（即 `int` 类型的最大值），`left + right` 会超出 `int` 的范围，导致溢出。
- 通过改写为 `left + ((right - left) / 2)`，可以避免溢出：
  - `(right - left)` 计算的是 `left` 和 `right` 之间的距离，这个值通常比 `left + right` 小得多，不容易溢出。
  - 然后除以 2，再加上 `left`，得到中间值。

### 适用场景

这种写法常用于二分查找（Binary Search）算法中，用于计算中间索引。二分查找需要对数组或区间的中间值进行计算，而 `left` 和 `right` 可能会非常大，因此需要避免溢出。

------

# 双指针法

**通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**正确的二分法一定要坚持**循环不变量原则**

定义快慢指针

- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

数组平方的最大值就在数组的两端，不是最左边就是最右边，不可能是中间。

此时可以考虑双指针法了，i指向起始位置，j指向终止位置。

### 滑动窗口

接下来就开始介绍数组操作中另一个重要的方法：**滑动窗口**。

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

# 循环输入的方法

```cpp
while(cin>>a>>b){}
```

# 前缀和

前缀和的思想是重复利用计算过的子数组之和，从而降低区间查询需要累加计算的次数。

**前缀和 在涉及计算区间和的问题时非常有用**

例如，我们要统计 vec[i] 这个数组上的区间和。

我们先做累加，即 p[i] 表示 下标 0 到 i 的 vec[i] 累加 之和。

如图：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20240627110604.png)

如果，我们想统计，在vec数组上 下标 2 到下标 5 之间的累加和，那是不是就用 p[5] - p[1] 就可以了。

为什么呢？

`p[1] = vec[0] + vec[1];`

`p[5] = vec[0] + vec[1] + vec[2] + vec[3] + vec[4] + vec[5];`

`p[5] - p[1] = vec[2] + vec[3] + vec[4] + vec[5];`

这不就是我们要求的 下标 2 到下标 5 之间的累加和吗。

如图所示：

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20240627111319.png)

`p[5] - p[1]` 就是 红色部分的区间和。

而 p 数组是我们之前就计算好的累加和，所以后面每次求区间和的之后 我们只需要 O(1) 的操作。

**特别注意**： 在使用前缀和求解的时候，要特别注意 求解区间。

如上图，如果我们要求 区间下标 [2, 5] 的区间和，那么应该是 p[5] - p[1]，而不是 p[5] - p[2]

### C++ 代码 面对大量数据 读取 输出操作，最好用scanf 和 printf，耗时会小很多
